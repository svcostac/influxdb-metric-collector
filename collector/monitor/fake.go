package monitor

import (
	"time"
	"fmt"
	"sync"
	"math/rand"
	"collector/types"
)

// min and max limits for utilization generated by normal clients (I aproximate between 10 - 20 %)
var MIN_USAGE = 10.0
var MAX_USAGE = 20.0

// Question: how do I define high usage?

type FakeMonitor struct {
	config *types.FakeMonitorConfig
	minPollInterval int
	queue chan<- *types.LocalLoad
}

func NewFakeMonitor(config *types.FakeMonitorConfig,  c chan<- *types.LocalLoad) *FakeMonitor {
	return &FakeMonitor {
		config:			config,
		minPollInterval: 1,
		queue: 			 c,
	}
}

func (m *FakeMonitor) Run(wg *sync.WaitGroup, stopCh <-chan struct{}) {
	if m.config.MaxRequests == -1 {
		for {
			select {
				case _ = <- stopCh:
					return
				default: 
					m.waitRandom()
				    value := m.ReadLoad("xxx")
				    fmt.Printf("%v Read load %v from client %v\n", time.Now(), value.CPU, value.Sender)
				    m.queue <- value
			}
		}
	}
	for r := 0; r < m.config.MaxRequests; r++ {
	    m.waitRandom()
	    value := m.ReadLoad("xxx")
	    fmt.Printf("%v Read load %v from client %v\n", time.Now(), value.CPU, value.Sender)
	    m.queue <- value
	}
	
	fmt.Printf("Finishing client %s\n", m.config.Name)
	wg.Done()
}

func (m *FakeMonitor) waitRandom() {
	/*
	The agents waits a random time before reading the utilization and sending it to the server. This provides
	a high chance that requests do not happen in bursts. There is an upper bound on the wait time that is
	configurable (PollInterval)
	*/
	timeToSleep := m.minPollInterval + rand.Intn(m.config.PollInterval - m.minPollInterval)
	time.Sleep(time.Duration(timeToSleep) *  time.Second)
}

func (m *FakeMonitor) ReadLoad(process string) *types.LocalLoad {
	// generate random value with a .2 probability to be high
	prob := rand.Intn(100)
	if (float64(prob) > 90) || m.config.HasHighUsage {
		// generate some high CPU utilization from time to time
		val := 80.0 + rand.Float64()*(MAX_USAGE - MIN_USAGE)
		return &types.LocalLoad {
					CPU: val,
					Sender: m.config.Name,
				}
	}
	// in the normal case clients generate low CPU utilization
	val := MIN_USAGE + rand.Float64()*(MAX_USAGE - MIN_USAGE)
	return &types.LocalLoad {
		CPU: float64(val),
		Sender: m.config.Name,
	}
}
